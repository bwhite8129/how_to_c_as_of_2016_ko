# 2016의 C 사용법

이 문서는 2015년 초에 썼지만, 어디에 내보내지는 않았습니다. 초안 폴더에 쳐박아둔채 아무에게도 보여주지 않았기 때문에 거의 다듬어지지 않은 글입니다. 딱 하나, 2015만 2016으로 바꾸어 내보냈습니다.

수정/개선/불만 무엇이든 편하게 말씀해주세요. - Matt<matt@matt.sh>

Keith Thompson이 써준 수정 사항들과 다른 의견들은 [howto-c-response](https://github.com/Keith-S-Thompson/how-to-c-response/blob/master/README.md)에서 확인하세요.

이제 글 시작합니다.

C 첫 번째 규칙은, 안쓸 수 있다면 쓰지 말라는 것입니다.

꼭, C로 프로그램을 작성해야한다면, 현대의 규칙을 따르세요.

C는 1970년대 초부터 쓰여왔습니다. 사람들은 C가 진화하며 거쳐온 어느 지점에서 "C를 배웠"고, 한 번 배운 후에는 그 지식이 잘 업데이트 되지 않았습니다. 그래서 각자가 처음 배웠을 시절의 C에 기반하여 모두 다른 생각들을 갖게 되었습니다.

C 개발에 대하여 "내가 8~90년대에 배운 것"에 갇히지 않는 것이 중요합니다.

이 글에서는 독자가 현대의 표준을 지원하는 현대적인 플랫폼 위에서 작업을 한다고 가정합니다. 오래된 레거시 호환에 대한 요구사항은 없다고 말이지요. 몇몇 회사가 20년된 시스템을 업그레이드하기 싫어한다고 해서, 전세계 모두가 고대의 표준에만 얽매여있을 수는 없습니다.

## 사전 점검
c99 표준 (c99는 "1999년에 만들어진 C 표준"을 의미합니다. c11은 "2011년에 만들어진 C 표준"입니다. 즉 11이 99보다 최신입니다).
- clang, 기본
  - clang은 기본으로 C11의 확장된 버전(`GNU C11 모드`)을 사용합니다. 따라서 현대적인 기능을 사용하는데 아무 옵션도 필요없습니다.
  - C11 표준을 사용하려면, `-std=c11`을 주면 됩니다. C99 표준을 쓰고 싶다면, `-std=c99`를 주면 됩니다.
  - clang은 gcc보다 컴파일이 더 빠릅니다.
- gcc는 `-std=c99`나 `-std=c11`를 주어야합니다.
  - gcc는 clang보다 컴파일은 느리지만, *가끔씩* 더 빠른 코드를 만들어냅니다. 성능비교와 회귀 테스트(Regression test)가 중요합니다.
  - gcc-5는 (clang과 동일하게) `GNU C11 모드`가 기본입니다.  정확한 C11이나 C99 표준을 사용하고 싶다면, `-std=c11`이나 `-std=c99`를 주면 됩니다.
  
최적화
- -O2, -O3
  - 일반적으로는 `-O2`를 쓰면 됩니다. 때로는 `-O3`가 필요할 수도 있습니다. 각 레벨(과 각 컴파일러)로 측정해보고 성능이 가장 좋은 버전을 사용하세요.
- -Os
  - (당연하지만) 캐시효율이 중요하다면, `-Os`가 도움이 됩니다.

경고
- `-Wall -Wextra -pedantic`
  - [최신 컴파일러 버전](https://twitter.com/oliviergay/status/685389448142565376)에서는 -Wpedantic을 사용해야합니다. 하지만 보다 넓은 하위 호환성을 위하여 -pedantic도 여전히 지원하고 있습니다.
- 테스트 중에는 모든 플랫폼에서 `-Werror` 와 `-Wshadow`를 추가하세요.
  - 실제 배포용 소스에 `-Werror`를 사용하는 것은 조금 까다롭습니다. 플랫폼과 컴파일러, 라이브러리에 따라서 다른 경고를 낼 수 있기 때문입니다.  어떤 플랫폼의 GCC가 이전에 경험하지 못한 새롭고 놀라운 방법으로 경고를 한다고 해서, 전체 빌드가 실패하도록 만들고 싶지는 않을 테니까요.
- extra fancy options include `-Wstrict-overflow` `-fno-strict-aliasing`
  - `-fno-strict-aliasing`를 사용하지 않으면, 객체를 정확하게 생성한 타입으로만 사용해야합니다. 이미 존재하는 C 코드들에서 타입을 바꿔가며 사용하는 경우가 많으므로, `-fno-strict-aliasing`을 사용하는 것이 훨씬 안전한 선택입니다. 소스 코드 전체를 통제할 수 있는 상황이 아니라면요.
- 현재, Clang이 적법한 문법에 대하여 경고를 내고 있습니다.  따라서 `-Wno-missing-field-initializers`를 사용해야 합니다. GCC는 4.7.0 이후 버전에서는 이 경고가 나오지 않습니다.

빌드
- 컴파일 단위
  - 가장 일반적인 C 프로젝트 빌드 방법은, 각 소스 파일을 각각 오브젝트 파일로 바꾼 후, 마지막에 이 오브젝트 파일들을 하나로 링크하는 방식입니다. 이 방법은 점진적 개발에는 좋지만, 성능이나 최적화에는 약간 안좋은 부분이 있습니다. 컴파일러가 여러 파일에 걸쳐있는 최적화 가능한 요소를 찾아서 최적화할 수 없기 때문입니다.
- LTO(Link Time Optimization: 링크 타임 최적화)
  - LTO는 이 "컴파일 단위간 소스코드 분석과 최적화 문제"를 해결합니다. LTO는 오브젝트 파일에 중간단계 결과물을 함께 저장합니다. 그래서 링크 시에 컴파일 단위 사이에 걸쳐있는 소스코드 최적화가 가능합니다. (이 때문에 링크 속도가 느려질텐데, `make -j`를 사용하면 도움이 됩니다.)
  - [clang LTO](http://llvm.org/docs/LinkTimeOptimization.html) ([guide](http://llvm.org/docs/GoldPlugin.html))
  - [gcc LTO](https://gcc.gnu.org/onlinedocs/gccint/LTO-Overview.html)
  - 2016년 현재, clang과 gcc는 `-flto` 옵션만 오브젝트 파일 컴파일과 최종 라이브러리/프로그램 링크시에 추가해주면 LTO가 동작합니다.
  - `LTO`는 아직 더 발전해야합니다. 프로그램에서 직접 사용되지는 않지만 다른 추가 라이브러리에서 사용할 수도 있는 코드가 있을 수 있습니다. LTO는 최종 링크를 할 때 사용되지 않거나, 사용할 수 없는, 그리고 최종 링크 결과물에 포함시킬 *필요가 없는* 함수나 코드를 찾아서 제거해버릴 수 있을 겁니다.

아키텍처
- `-march=native`
  - 컴파일러가 CPU의 전체 기능을 사용할 수 있도록 합니다.
  - 다시 한 번, 성능 테스트와 회귀 테스트가 중요합니다. 수행 결과를 여러 컴파일러와 컴파일러 버전에 따라 비교도 해보아야합니다. 활성화시킨 최적화로 인해 나쁜 부수효과가 생겼을 수도 있으니까요.
- 프로그램을 빌드하는 기기와 실행하는 기기가 다르다면, `-msse2`와 `-msse4.2`도 유용할 수 있습니다.

## 코드 작성
### 타입
새로 작성하는 코드에 `char`나 `int`, `short`, `long`, `unsigned` 같은 것들을 쓰고 있다면, 잘못하고 있는 겁니다.

현대적인 프로그램이라면, `#include <stdint.h>`를 넣고, 표준 타입들을 사용해야 합니다.

공통 표준 타입들은 다음과 같습니다:

- `int8_t`, `int16_t`, `int32_t`, `int64_t` — 부호가 있는 정수
- `uint8_t`, `uint16_t`, `uint32_t`, `uint64_t` — 부호가 없는 정수
- `float` — 표준 32비트 부동소수점
- `double` - 표준 64비트 부동소수점

더 이상 `char`는 쓰지 않습니다. C에서 `char`는 이름을 잘못 붙였고, 잘못 사용되었습니다.

개발자들은 부호가 없는 바이트 조작을 할 때도 일상적으로 `char`를 "바이트"로 오용해왔습니다. 부호가 없는 한 바이트/8비트 값이라면 `uint8_t`를, 연속한 여러 바이트/8비트 값이라면 `uint8_t *`를 쓰는 것이 훨씬 깔끔합니다. 

#### 예외적으로 `char`를 쓰는 경우
2016년에 *유일하게* `char`를 쓸 수 있는 경우는, 이미 존재하는 API가 `char`를 필요로 하는 곳입니다. 예를 들어 `strncat`이나 "%s"를 printf에 쓸 때 등이 있습니다. 또는 읽기만 하는 문자열을 선언할 때입니다. 예를 들어 `const char *hello = "hello"`. C에서 문자열("hello")은 char [] 타입이기 때문입니다.

또한 C11에서는 유니코드를 기본 지원하는데, UTF-8 문자열 표현의 타입도 여전히 char *입니다. `const char *abcgrr = u8"abc😬";`같은 멀티바이트 문자열이더라도요.

